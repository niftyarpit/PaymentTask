//
//  PaymentHomeWorker.swift
//  Payment
//
//  Created by ARPIT  SRIVASTAVA on 03/12/18.
//  Copyright (c) 2018 Arpit. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

enum FetchDataResult<U> {
    case success(result: U)
    case failure(error: FetchDataError)
}

enum FetchDataError {
    case cannotFetch(String)
}

class PaymentHomeWorker {
    
    func fetchPaymentOptionsData(completionHandler: @escaping (_ result: FetchDataResult<[String: Any]>) -> Void) {
        fetchPaymentOptionsDataFromStaticJson(completionHandler: completionHandler)
        //fetchPaymentOptionsDataFromAPI(completionHandler: completionHandler)
    }
    
    private func fetchPaymentOptionsDataFromStaticJson(completionHandler: @escaping (_ result: FetchDataResult<[String: Any]>) -> Void) {
        guard let path = Bundle.main.path(forResource: "PaymentHomeData", ofType: "json") else { return }
        do {
            let jsonData = try NSData(contentsOfFile: path, options: NSData.ReadingOptions.mappedIfSafe)
            do {
                let json: [String: Any] = try JSONSerialization.jsonObject(with: jsonData as Data,
                                                                           options: JSONSerialization.ReadingOptions.mutableContainers) as! [String: Any]
                print(json)
                if let custom = json[PaymentHomeConstants.Keys.custom] as? [String: Any] {
                    let responseNode = parseResponse(with: custom)
                    completionHandler(FetchDataResult.success(result: ["responseNode": responseNode]))
                } else {
                    completionHandler(FetchDataResult.failure(error: FetchDataError.cannotFetch("Improper Data Format")))
                }
            } catch {
                completionHandler(FetchDataResult.failure(error: FetchDataError.cannotFetch("Improper Data Format")))
            }
        } catch {
            completionHandler(FetchDataResult.failure(error: FetchDataError.cannotFetch("Improper Data Format")))
        }
    }
    
    private func fetchPaymentOptionsDataFromAPI(completionHandler: @escaping (_ result: FetchDataResult<[String: Any]>) -> Void) {
        guard let urlComponents = URLComponents(string: "https://www.mocky.io/v2/5c00c2e93200005700b28857"),
            let url = urlComponents.url else { return }
        let defaultSession = URLSession(configuration: .default)
        defaultSession.dataTask(with: url) { [weak self] data, response, error in
            guard let strongSelf = self else { return }
            if let _ = error {
                completionHandler(FetchDataResult.failure(error: FetchDataError.cannotFetch("Improper Data Format")))
            } else {
                do {
                    let json: [String: Any] = try JSONSerialization.jsonObject(with: data!,
                                                                               options: JSONSerialization.ReadingOptions.mutableContainers) as! [String: Any]
                    print(json)
                    if let custom = json[PaymentHomeConstants.Keys.custom] as? [String: Any] {
                        let responseNode = strongSelf.parseResponse(with: custom)
                        completionHandler(FetchDataResult.success(result: ["responseNode": responseNode]))
                    } else {
                        completionHandler(FetchDataResult.failure(error: FetchDataError.cannotFetch("Improper Data Format")))
                    }
                } catch {
                    completionHandler(FetchDataResult.failure(error: FetchDataError.cannotFetch("Improper Data Format")))
                }
            }
            }.resume()
    }
    
    private func parseResponse(with data: [String: Any]) -> ResponseNode {
        let alert_info = data[PaymentHomeConstants.Keys.alert_info] as? String ?? EMPTYSTRING
        let alert_error = data[PaymentHomeConstants.Keys.alert_error] as? String ?? EMPTYSTRING
        var netbankingNode: ResponseNode.Netbanking?
        var cardNode: ResponseNode.Card?
        var upiNode: ResponseNode.UPI?
        var wallets: [ResponseNode.Wallet] = []
        if let netbanking = data[PaymentHomeConstants.Keys.netbanking] as? [String: Any] {
            let enabled = netbanking[PaymentHomeConstants.Keys.enabled] as? Bool ?? false
            let pg = netbanking[PaymentHomeConstants.Keys.pg] as? String ?? EMPTYSTRING
            var preferredBanks: [ResponseNode.Netbanking.Preferred] = []
            if let preferred = netbanking[PaymentHomeConstants.Keys.preferred] as? [[String: Any]] {
                for bank in preferred {
                    let priority = bank[PaymentHomeConstants.Keys.Preferred.priority] as? Int ?? 0
                    let logo = bank[PaymentHomeConstants.Keys.Preferred.logo] as? String ?? EMPTYSTRING
                    let code = bank[PaymentHomeConstants.Keys.Preferred.code] as? String ?? EMPTYSTRING
                    let name = bank[PaymentHomeConstants.Keys.Preferred.name] as? String ?? EMPTYSTRING
                    let preferredBank = ResponseNode.Netbanking.Preferred(priority: priority,
                                                                          logo: logo,
                                                                          code: code,
                                                                          name: name)
                    preferredBanks += [preferredBank]
                }
            }
            let all = netbanking[PaymentHomeConstants.Keys.all] as? [String: Any] ?? [:]
            netbankingNode = ResponseNode.Netbanking(enabled: enabled,
                                                     pg: pg,
                                                     preferred: preferredBanks,
                                                     all: all)
        }
        
        if let card = data[PaymentHomeConstants.Keys.card] as? [String: Any] {
            let enabled = card[PaymentHomeConstants.Keys.enabled] as? Bool ?? false
            let pg = card[PaymentHomeConstants.Keys.pg] as? String ?? EMPTYSTRING
            var savedCards: [ResponseNode.Card.SavedCard] = []
            if let saved = card[PaymentHomeConstants.Keys.saved] as? [[String: Any]] {
                for savedCard in saved {
                    let logo = savedCard[PaymentHomeConstants.Keys.Preferred.logo] as? String ?? EMPTYSTRING
                    let number = savedCard[PaymentHomeConstants.Keys.number] as? String ?? EMPTYSTRING
                    savedCards += [ResponseNode.Card.SavedCard(logo: logo,
                                                               number: number)]
                }
            }
            cardNode = ResponseNode.Card(enabled: enabled,
                                         pg: pg,
                                         cards: savedCards)
        }
        if let wallet = data[PaymentHomeConstants.Keys.wallet] as? [[String: Any]] {
            for item in wallet {
                let name = item[PaymentHomeConstants.Keys.Wallet.name] as? String ?? EMPTYSTRING
                let code = item[PaymentHomeConstants.Keys.Wallet.code] as? String ?? EMPTYSTRING
                let logo = item[PaymentHomeConstants.Keys.Wallet.logo] as? String ?? EMPTYSTRING
                let pg = item[PaymentHomeConstants.Keys.pg] as? String ?? EMPTYSTRING
                let linking_enabled = item[PaymentHomeConstants.Keys.Wallet.linking_enabled] as? Bool ?? false
                let enabled = item[PaymentHomeConstants.Keys.enabled] as? Bool ?? false
                let lWallet = ResponseNode.Wallet(name: name,
                                                  code: code,
                                                  logo: logo,
                                                  pg: pg,
                                                  linking_enabled: linking_enabled,
                                                  enabled: enabled)
                wallets += [lWallet]
            }
        }
        
        if let upi = data[PaymentHomeConstants.Keys.upi] as? [String: Any] {
            let enabled = upi[PaymentHomeConstants.Keys.enabled] as? Bool ?? false
            let pg = upi[PaymentHomeConstants.Keys.pg] as? String ?? EMPTYSTRING
            upiNode = ResponseNode.UPI(enabled: enabled,
                                       pg: pg)
        }
        let response = ResponseNode(alert_info: alert_info,
                                    alert_error: alert_error,
                                    card: cardNode,
                                    netbanking: netbankingNode,
                                    wallet: wallets,
                                    upi: upiNode)
        return response
    }
}
