//
//  PaymentHomeInteractor.swift
//  Payment
//
//  Created by ARPIT  SRIVASTAVA on 03/12/18.
//  Copyright (c) 2018 Arpit. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

protocol PaymentHomeBusinessLogic {
    func fetchPaymentOptions(request: PaymentHome.PaymentOptions.Request)
}

protocol PaymentHomeDataStore {
    var banksInfo: [String: Any] {get}
}

class PaymentHomeInteractor: PaymentHomeBusinessLogic, PaymentHomeDataStore {
    var presenter: PaymentHomePresentationLogic?
    lazy var worker = PaymentHomeWorker()
    var totalResponseNode: ResponseNode!
    var banksInfo: [String: Any] = [:]
    private var expandedCardIndexes: [Int] = []
    
    func fetchPaymentOptions(request: PaymentHome.PaymentOptions.Request) {
        if request.isNetworkFetch {
            worker.fetchPaymentOptionsData {[weak self] (result: FetchDataResult) in
                guard let strongSelf = self else { return }
                switch result {
                case .success(let fetchedData):
                    let responseNode = fetchedData["responseNode"] as! ResponseNode
                    strongSelf.totalResponseNode = responseNode
                    strongSelf.constructAndPresentResponse(from: responseNode)
                case .failure(let error):
                    switch error {
                    case .cannotFetch(let errorMessage):
                        break
                    }
                }
            }
        } else {
            populateExpandedCardIndexes(using: request.selectedCardIndex)
            constructAndPresentResponse(from: totalResponseNode)
        }
    }
    
    private func constructAndPresentResponse(from responseNode: ResponseNode) {
        let response = getResponse(from: responseNode)
        banksInfo = response.netbanking?.all ?? [:]
        presenter?.presentPaymentOptions(response: response)
    }
    
    private func populateExpandedCardIndexes(using selectedIndex: Int) {
        if expandedCardIndexes.contains(selectedIndex) {
            expandedCardIndexes.removeAll()
        } else {
            expandedCardIndexes.removeAll()
            expandedCardIndexes.append(selectedIndex)
        }
    }
    
    private func getResponse(from responseNode: ResponseNode) -> PaymentHome.PaymentOptions.Response {
        let alertInfo = responseNode.alert_info
        let alertError = responseNode.alert_error
        var netbankingNode: PaymentHome.PaymentOptions.Response.NetbankingResponse?
        var cardNode: PaymentHome.PaymentOptions.Response.CardResponse?
        var upiNode: PaymentHome.PaymentOptions.Response.UPIResponse?
        var wallets: [PaymentHome.PaymentOptions.Response.WalletResponse] = []
        var otherWallets: [PaymentHome.PaymentOptions.Response.OtherWalletResponse] = []
        if let netbanking = responseNode.netbanking, true == netbanking.enabled {
            let pg = netbanking.pg
            var preferredBanks: [PaymentHome.PaymentOptions.Response.NetbankingResponse.PreferredResponse] = []
            for bank in netbanking.preferred {
                let priority = bank.priority
                let logo = bank.logo
                let code = bank.code
                let name = bank.name
                preferredBanks += [PaymentHome.PaymentOptions.Response.NetbankingResponse.PreferredResponse(priority: priority,
                                                                                                            logo: logo,
                                                                                                            code: code,
                                                                                                            name: name)]
            }
            let all = netbanking.all
            netbankingNode = PaymentHome.PaymentOptions.Response.NetbankingResponse(pg: pg,
                                                                                    preferred: preferredBanks,
                                                                                    all: all)
        }
        if let card = responseNode.card, true == card.enabled {
            let pg = card.pg
            var cards: [PaymentHome.PaymentOptions.Response.CardResponse.SavedCardResponse] = []
            for (index, lCard) in card.cards.enumerated() {
                let logo = lCard.logo
                let number = lCard.number
                let isExpanded = expandedCardIndexes.contains(index)
                cards += [PaymentHome.PaymentOptions.Response.CardResponse.SavedCardResponse(logo: logo,
                                                                                             number: number,
                                                                                             isExpanded: isExpanded)]
            }
            cardNode = PaymentHome.PaymentOptions.Response.CardResponse(pg: pg,
                                                                        cards: cards)
        }
        if let upi = responseNode.upi, true == upi.enabled {
            let pg = upi.pg
            upiNode = PaymentHome.PaymentOptions.Response.UPIResponse(pg: pg)
        }
        for item in responseNode.wallet {
            let name = item.name
            let code = item.code
            let logo = item.logo
            let pg = item.pg
            let linkingEnabled = item.linking_enabled
            let enabled = item.enabled
            let linked = item.linked
            if enabled {
                if linkingEnabled {
                    wallets += [PaymentHome.PaymentOptions.Response.WalletResponse(name: name,
                                                                                   code: code,
                                                                                   logo: logo,
                                                                                   pg: pg,
                                                                                   linked: linked)]
                } else {
                    otherWallets += [PaymentHome.PaymentOptions.Response.OtherWalletResponse(name: name,
                                                                                             code: code,
                                                                                             logo: logo,
                                                                                             pg: pg)]
                }
            }
        }
        let response = PaymentHome.PaymentOptions.Response(alertInfo: alertInfo,
                                                           alertError: alertError,
                                                           card: cardNode,
                                                           netbanking: netbankingNode,
                                                           wallet: wallets,
                                                           otherWallet: otherWallets,
                                                           upi: upiNode)
        return response
    }
}
